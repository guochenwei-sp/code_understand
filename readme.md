# C语言代码工程分析工具架构设计方案

## 1. 项目概述
本工具旨在提供一个跨平台的、现代化的C语言代码理解环境，核心目标是解决大型C工程（如Linux内核模块、嵌入式系统）中代码阅读困难、依赖关系不透明的问题。

## 2. 与现有工具对比：VS Code + 插件与本工具的差异化定位

本工具的定位并非是与 VS Code 竞争成为一款通用代码编辑器，而是旨在填补现有 IDE (如 VS Code) 在**深度代码理解、架构审计和遗留代码分析**方面的短板。

### 2.1 核心定位的根本差异

| 维度         | VS Code + 插件 (C/C++ Extension)             | 本工具 (类似 Source Insight/Understand)                   |
| :----------- | :------------------------------------------- | :------------------------------------------------------ |
| **核心目标** | **编写 (Writing) & 调试 (Debugging)**          | **阅读 (Reading) & 理解 (Comprehension)**                 |
| **思维模式** | 局部思维：关注当前行、当前文件、补全下一行。 | 全局思维：关注模块关系、数据流向、整体架构。               |
| **数据引擎** | **LSP (Language Server Protocol)**。基于内存，针对“当前打开文件”优化，响应快但缺乏全局持久化数据。 | **关系数据库 (SQL/Graph DB)**。对全工程建立持久化索引，能回答复杂的全局查询（如“谁修改了这个全局变量”）。 |
| **交互重心** | 文本编辑器是绝对核心，其他都是辅助面板。     | 关系图、调用树、符号列表是核心，编辑器只是展示详情的窗口。   |

### 2.2 VS Code 现有痛点（本工具的价值主张）

1.  **缺乏“全局视角的”可视化**
    *   **VS Code 痛点**: 虽有 Call Hierarchy (调用层级)，但多以树状列表呈现，缺乏交互式、动态的关系图。现有图形插件通常生成静态图片，交互性差。
    *   **本工具优势**: 提供**可交互的、动态的关系图**，如点击节点展开下一级调用、高亮循环依赖、区分变量的“读”和“写”操作。

2.  **上下文信息的即时呈现 (Context Awareness)**
    *   **VS Code 痛点**: 通常需要悬停或跳转才能查看定义/引用，打断阅读流，容易迷失。
    *   **本工具优势**: 采用 **Source Insight 模式**，用户点击任何符号，无需跳转，底部 Context Window 自动显示定义，右侧 Relation Window 自动显示上下游，实现**不打断阅读流**的深度理解。

3.  **遗留代码（Legacy Code）与宏地狱处理**
    *   **VS Code 痛点**: 对于非标准构建配置或复杂条件编译宏的遗留项目，其 IntelliSense (智能感知) 经常失效。
    *   **本工具优势**: 可设计更“宽容”的模糊解析器，或允许用户手动配置宏环境，专门优化对历史悠久、宏定义复杂的 C 代码的解析能力。

4.  **架构级分析报表**
    *   **VS Code 痛点**: 缺乏直接提供模块间依赖、圈复杂度趋势、高风险区域等**工程架构层面**分析报告的能力。
    *   **本工具优势**: 能够生成针对管理者和架构师的工程体检报告，如模块依赖矩阵 (DSM)、分层图、代码复杂度分布等。

### 2.3 如何避免“重复造轮子”的陷阱

*   **不作为**:
    *   不尝试打造比 VS Code 更好用的通用文本编辑器，而是直接嵌入 **Monaco Editor**，保持编辑体验的一致性。
    *   不将重心放在“代码补全”和“即时语法检查”等 VS Code 强项上。

*   **重点发力点**:
    *   **图形化导航**: 专注于 Cytoscape.js 等库的交互设计，提供极其顺滑的图形化代码导航体验。
    *   **高级查询**: 提供强大的数据库查询能力，支持用户自定义复杂查询，例如查找特定模式的函数调用。
    *   **历史与趋势分析**: 结合版本控制系统 (Git)，分析代码演进历史，识别高风险代码区域或“Bug 热点”。

## 3. C语言架构分析技术栈详解

在C语言架构分析领域，本项目无需从零发明分析方法，而是采取**组合现有成熟技术**的策略。以下是本工具将采用的工业界主流技术栈。

### 3.1 核心解析与元数据提取 (The "Eyes")
架构分析的基础是准确理解代码。

*   **LLVM / LibClang (绝对主流)**
    *   **地位**: 工业标准。目前几乎所有现代 C/C++ 分析工具（包括 VS Code 插件、CLion、Sourcetrail）底层均基于此。
    *   **能力**: 能生成精确的 AST（抽象语法树），解析复杂的宏定义，提供 Token 级别的引用关系。
    *   **关键文件**: 利用 `compile_commands.json` (Compilation Database) 来确保 LibClang 准确解析项目配置（包括 include 路径和宏定义）。

### 3.2 架构依赖分析算法 (The "Brain")
基于解析出的元数据计算架构模型。

*   **DSM (Dependency Structure Matrix, 依赖结构矩阵)**
    *   **原理**: 用 N*N 矩阵表示模块间依赖。行代表调用者，列代表被调用者。
    *   **价值**: 极其直观地发现**循环依赖**（矩阵对角线上方的点）和**高内聚低耦合**问题。这也是本工具区别于 VS Code 的核心功能之一。
*   **Levelization (分层逻辑)**
    *   **原理**: 基于有向无环图 (DAG) 的拓扑排序，自动计算代码的“层级”。
    *   **用途**: 检查是否出现了“下层模块反向调用上层模块”的架构违规。

### 3.3 可视化技术栈 (The "Face")
C语言工程的依赖图通常非常庞大，传统绘图库难以支撑。

*   **Cytoscape.js / G6 (AntV)**
    *   **选型**: Cytoscape.js。
    *   **理由**: 现代 Web 图形库，支持 WebGL 加速，能处理数千个节点，支持力导向布局 (Force Atlas 2)，非常适合 Electron 环境。
*   **Graphviz (Dot)**: 仅作为后端布局算法引擎参考，不用于前端交互渲染。

### 3.4 行业标杆参考 (Benchmarks)
本工具的设计将参考以下两款顶级软件的优点：

*   **SciTools Understand**: 借鉴其 "Information Browser" 面板设计，学习如何聚合极其丰富的信息。
*   **Sourcetrail (已开源)**: 借鉴其“三窗口布局”（左侧搜索、中间图形、右侧代码）的高效交互逻辑。

## 4. 核心功能实现逻辑

### 4.1 代码解析与索引 (Core Engine)
这是最关键的部分。需要扫描用户指定的工程目录，建立符号数据库。

*   **技术栈**: Python (`clang` module) 或 C++ (`libclang`).
*   **流程**:
    1.  遍历所有 `.c` 和 `.h` 文件。
    2.  利用 `libclang` 解析每个文件，生成 AST (Abstract Syntax Tree)。
    3.  **提取符号**: 识别 函数定义、变量声明、结构体定义、宏定义。
    4.  **提取引用**: 遍历 AST 中的 `Cursor`，找到所有引用（CallExpr, VarRef）。
    5.  **存入数据库 (SQLite)**:
        *   `Table_Symbols`: ID, Name, Type (Func/Var/Struct), FilePath, Line, Column.
        *   `Table_Refs`: SourceID (调用者), TargetID (被调用者), RefType (Call/Read/Write).

### 4.2 变量与函数调用关系图 (可视化)
*   **需求**: 类似 Source Insight 的 "Relation Window"。
*   **实现**:
    *   当用户在前端点击某个变量/函数时，发送其 Symbol ID 给后端。
    *   后端查询 SQLite: `SELECT * FROM Table_Refs WHERE TargetID = ?` (谁调用了我) 或 `WHERE SourceID = ?` (我调用了谁)。
    *   前端使用 **Cytoscape.js** 渲染节点图。
    *   **变量级**: 区分 "读取(Read)" 和 "写入(Write)" 边，这对于分析数据流非常有用。

### 4.3 代码索引与快速导航
*   **实现**:
    *   利用 **SQLite FTS5** (Full-Text Search) 插件实现毫秒级符号搜索。
    *   前端集成 **Monaco Editor**。
    *   实现 "Go to Definition": 监听编辑器的 `CMD+Click` 事件，查询数据库中符号的定义位置，并跳转。

### 4.4 静态代码分析与Bug检测
*   **策略**: 不重复造轮子。
*   **实现**:
    *   封装开源工具 **Cppcheck** 或 **Clang-tidy**。
    *   通过 CLI 运行分析，解析其输出的 XML/JSON 报告。
    *   在编辑器侧边栏（Gutter）显示警告图标，并在底部面板列出所有潜在 Bug。

### 4.5 代码复杂度度量
*   **指标**: 圈复杂度 (Cyclomatic Complexity)。
*   **算法**: 在遍历 AST 时，统计每个函数体内的判定节点数量 (`if`, `for`, `while`, `case`, `&&`, `||`)。
*   **展示**: 在函数定义上方显示一个小徽章，例如 "Complexity: 15 (High)"。

### 4.6 工程架构分析
*   **实现**:
    *   **文件依赖矩阵 (DSM)**: 基于 `#include` 关系生成矩阵。
    *   **分层图**: 分析文件夹结构，结合函数调用跨度，生成模块间的依赖图。

### 4.7 版本管理与 Code Review
*   **技术**: `libgit2` (通过 PyGit2 或 NodeGit)。
*   **功能**:
    *   读取 Git History。
    *   **Review 模式**: 双栏 Diff 视图。
    *   **增强**: 在 Diff 视图中，依然支持 "点击跳转" 和 "查看调用关系"，这是传统 Git 客户端做不到的（通常 Git 客户端只有文本 Diff，没有语义理解）。

### 4.8 架构演进与合规性守护 (Architecture Evolution & Guarding)
这是针对团队协作与大型工程的高级功能，旨在宏观监控变更并防止架构腐蚀。

*   **功能一：架构 Diff 热力图 (Macro Visual Diff)**
    *   **目标**: 无论修改了多少个文件，管理者都能一眼看出本次版本迭代“动了哪个模块”。
    *   **实现**:
        1.  **映射**: 获取 Git Diff 的变更文件列表，根据文件路径映射到对应的架构模块节点。
        2.  **渲染**: 在高层架构图（模块图）上，对发生变更的模块进行**热力着色**。
            *   红色深浅代表变更幅度（修改行数或文件数）。
            *   点击“热点模块”，可向下钻取查看具体是哪个文件、哪个函数发生了变更。
*   **功能二：底层代码防误触 (Architecture Guarding)**
    *   **痛点**: 防止由于新人不熟悉架构，无意中修改了本应冻结的底层驱动或核心库，或者引入了非法的跨层调用。
    *   **实现**:
        1.  **规则配置**: 允许将特定模块标记为 `Locked` (冻结/稳定区) 或 `Core` (核心保护区)。
        2.  **自动检测**: 在 Commit 提交前或 CI 阶段，工具分析变更集。
        3.  **报警**: 如果变更涉及 `Locked` 模块的文件，或者新增的函数调用违反了分层规则（如：UI层直接调用了HAL层私有函数），系统会在架构图上弹出**醒目的违规警告**，并生成拦截报告。

## 5. 推荐技术栈 (复用你的现有经验)

| 组件 | 推荐技术 | 理由 |
| :--- | :--- | :--- |
| **GUI 框架** | **Electron** | 跨平台，生态极其丰富，支持 Monaco Editor。 |
| **前端 UI** | **React + Ant Design** | 你的强项，组件库完善。 |
| **图形库** | **Cytoscape.js** | 专为网络关系图设计，性能好，交互强。 |
| **代码编辑器** | **Monaco Editor** | VS Code 同款，体验最佳。 |
| **后端/分析层** | **Python (FastAPI)** | 开发速度快，`libclang` 的 Python 绑定很好用。 |
| **数据库** | **SQLite** | 单文件，轻量，支持 SQL 查询复杂关系。 |
| **分析核心** | **LLVM (LibClang)** | 解析 C 语言的唯一真神。 |

## 6. 开发路线图 (MVP 阶段)

1.  **Phase 1: 基础解析**
    *   搭建 Python + LibClang 环境。
    *   能够解析单个 C 文件，打印出所有函数名和变量名。
2.  **Phase 2: 数据入库**
    *   设计 SQLite 表结构。
    *   实现批量扫描工程目录，建立完整的符号表。
3.  **Phase 3: 简单 UI**
    *   Electron 壳子，左侧文件树，右侧 Monaco Editor。
    *   实现 "点击跳转定义"。
4.  **Phase 4: 可视化**
    *   集成 Cytoscape.js。
    *   实现 "点击函数，弹出调用图"。

## 7. 潜在难点

*   **预处理宏 (Macros)**: C语言大量的 `#ifdef` 可能会导致 LibClang 解析时跳过某些代码块。需要允许用户配置 `Define` 或解析 `compile_commands.json`。
*   **性能**: 解析像 Linux Kernel 这样的大项目非常耗时。需要实现**增量解析**（只解析修改文件的时间戳）。